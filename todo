

Cahier des charges:

	Obligatoire de l ecole :
			• Ajouter une "signature" à ce binaire
			• A tous les binaires présents dans un dossier temporaire spécifique  ( /tmp/test et /tmp/test2 )
            • AUCUN OUTPUT NE SERA FAIT
            • ATTENTION ! Une seule infection sur ledit binaire est possible.

    Bonus:
            • Pestillance :
                    • la routine d’infection soit obfusquée. Elle ne doit pas être clairement visible dans
                      votre code. Vous devrez d’ailleurs penser à inclure une méthode de désobfuscation
                      dans votre programme, qui décryptera et lancera l’infection.
                    • la routine de désobfuscation ne s’exécute pas si un processus spécifique est actif
                    sur la machine cible.
                    • la routine de désobfuscation ne s’exécute pas si vous tentez d’utiliser un debugueur
                    pour exécuter un binaire infecté ou le virus en lui même
            • War :
                   • Ce coup-ci, on va rendre encore plus discret notre virus en apprenant à modifier un
                    binaire au runtime pour modifier sa signature. Ici, on va donc modifier la signature à
                    implémenter va et devra embarquer un FINGERPRINT supplémentaire pour avoir a peu
                    près cette forme :

					• Ce FINGERPRINT est important ici, car ce sera cette partie qui sera modifié à l’exécution de vos binaires infectés. Ce FINGERPRINT ne sera JAMAIS le même quelque
                    soit la source de l’infection (virus lui meme ou binaire infecté). Bien sur, l’infection ne
                    modifie en rien le fonctionnement du ou des binaire(s) infectés dans les dossiers concernés.

    Bonus FUN:
            • Utiliser tous le path present dans l ENV pour rechercher des binaires => checker les droits
            • Checker depuis la racine (lorsque trouve un binaire a infecter, infection de tous les binaires du dossier, puis execute une copie du payload sur chaque dossier, puis exit (pas de parents, si un enfant ou parent tombe la recherche continue d etre faite))
            • Possibilite d'ajouter un payload au choix en argv sur le programme qui infect

Logique:

		NEED SEGMENT with EXEC permission
			- check process
			- map de la memoire
			- cpy/decrypt le code
			- donner les droits
			- l'executer
			- jump original entry

		NEED SEGMENT with READ permission

		- si lance via le binaire changer la signature
		- si un path n est pas set verifier le dossier ou je me trouve si il y a des binaires pouvant etre infecte (no infected)
		- verifier de meme pour le PATH dans l'ENV
		- verifier si il existe des dossiers dans le repertoire
					:Si oui executer une copie du virus pour chaque dossier et set un path

		un pre_payload      NEED EXEC permission
		payload             NEED READ permission

		- rechercher un GAP pour le pre_payload with correct permission
		- rechercher un GAP pour le payload with correct permission
					: si non ajouter les permissions


		- Ouvrir tous les path possible
1f140

pre_payload:
		function_01: checker process
			parametre: AUCUN
			return boolean 0 == good / 1 == exit
		function_02: map memoire
			parametre: 1 size
			return 2 valeurs PTR + SIZE_MAPED
		function_03: decrpy/cpy
			parametres: 6 :payload_src + x,size,key,src_virus, size_virus,dest_virus
fork ? avec un env different function_04: mprotect / and call
			parametres: 2 :dest,size_dest
			return
		jump to original


payload:        need magic number to know if I'm binnary or juste a deamon_payload
parametre: pre_payload, pre_payload_size, payload, payload_size, magic number
		checker_magic number
			function_11: changement signature
		function_12: checker tous les fichiers/dossiers


		quand un fichier est trouve:
			- rechercher un GAP pour le pre_payload with correct permission
            - rechercher un GAP pour le payload with correct permission
            					: si non ajouter les permissions


